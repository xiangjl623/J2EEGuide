# 垃圾收集器与内存分配策略

## 1 概述

​	大部分人会把垃圾回收（Garbage Collection，GC）当做Java的伴生产物，事实上，GC的历史要比Java久远。对于GC学习,我们主要考虑三个问题：

- 哪些内存需要回收 ?
- 什么时候回收 ?
- 如何回收?

## 2 对象已死吗

​	在堆里存放着Java中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事就是要确认哪些对象还“存活”着，哪些已经“死去”（不可能再被使用）。

### 2.1 引用计数算法

​	引用计数算法（Reference Counting）：给对象添加一个引用计数器，每当有一个地方引用它，计数器就+1，引用失效，计数器-1：任何时刻计数器为0的对象就是不能再被使用的。

​	这种算法实现简单，判定效率也很高，但它难以解决对象之间相互循环引用的问题，如果两个对象中存在互相引用，就无法通知GC收集器回收它们。Java虚拟机并不是通过引用计数算法来判断对象是否存活的。

### 2.2 可达性分析算法

​	在主流商用程序语言（Java、C#）的主流实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。基本思路是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

![1](images\1.jpg)

​	Java中，可作为GC Roots的对象包括以下几种：

- 虚拟机栈(栈帧中的本地变量表)中引用的对象。
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中Native方法引用的对象

### 2.3 再谈引用

​	无论是引用计数算法还是可达性分析算法，判断对象是否存活都与“引用”有关，在JDK1.2之前，Java中的引用的定义：如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹但太过狭隘，一个对象在这种定义下只有被引用或者没有被引用这两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力，我们希望能描述这样一类对象：**当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象**。很多系统的缓存功能都符合这样的应用场景。

​	JDK1.2之后Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用4中(Phantom Reference)，这4种引用强度依次逐渐减弱。

可参考：https://blog.csdn.net/baidu_22254181/article/details/82555485

- 强引用就是指在程序代码之中普遍存在的，类似`Object obj = new Object()`这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有用但非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK1.2之后，提供了SoftReference类来实现软引用。
- 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。
- 虚引用也称为幽灵引用或者幻影引用，它是一种最弱的引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象收集器会收时收到一个系统通知。JDK1.2之后提供了PhantomReference类实现虚引用。

### 2.4 生存还是死亡

​	即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象的死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选条件时此对象是否有必要执行`finalize()`方法。当对象没有覆盖`finalize()`方法，或者`finalize()`方法已经被jvm调用过，虚拟机将这两种情况都视为“没有必要执行”。

​	如果这个对象被判定为有必要执行finalize方法，那么这个对象会放置在F-Queue队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它（调用finalize方法）。执行是指触发这个方法，但不承诺会等待它运行结束，因为如果一个对象在F-Queue中执行缓慢，或者发生了死循环，很可能导致其他对象永久处于等待状态，甚至整个内存回收系统崩溃。稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要再finalize()中拯救自己——只需要重新与引用链上任意一个对象建立关联，譬如把自己（this）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。

### 2.5 回收方法区

​	很多人认为方法区是没有垃圾收集的，Java虚拟机规范中确实说过不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的性价比很低：在堆中，尤其是新生代，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而方法区的垃圾收集效率远低于此。

​	方法区的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。假如当前系统中没有一个对象引用了当前常量池中的某个常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

​	判断一个类是否无用的条件比判断常量苛刻的多，类需要满足以下三个条件，才会被判定为“无用的类”

- 该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类方法。

## 3 垃圾回收算法

### 3.1 标记-清除算法

​	算法分为“标记”和"清除"(Mark-Sweep)两个阶段,首先标记出需要回收的对象,在标记完成后统一回收。后续的收集算法都基于这种思路并对其不足进行改进。 

 ![2](images\2.jpg)

​	缺点：一是效率问题，标记和清除两个阶段的效率都不高；另一个是空间问题，标记清楚后会产生大量不连续的内存碎片，空间碎片太多可能导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集。

### 3.2 复制算法

​	为了解决效率问题,一种称为"复制"(Copying)的收集算法出现了,它将可用内存按容量划分为大小相等的两块,每次只使用其中的一块.当这块内存用完了,就将还存活着的对象复制到另外一块上面,然后把已使用过的内存空间一次清理掉.这样使得每次都是对整个半区进行内存回收，也不会出现内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单、高效。但**代价是将内存缩小为了原来的1/2**。

   ![3](images\3.jpg)

​	商业虚拟机都采用这种手机算法来回收新生代。IBM研究表明，新生代中98%的对象都是“朝生夕死”，所以不需要1:1的比例来划分内存，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中和存活的对象一次性复制到另外一块Survivor上，最后清理Eden和用过的Survivor空间。HotSpot默认Eden和Survivor大小比例为8:1。也就是新生代中可用空间为整个新生代的90%，只有10%会被“浪费”。当Survivor空间不够用时，需要依赖其他内存（老年代）进行分配担保。

### 3.3 标记-整理算法

​	复制收集算法在对象存活率较高时要进行较多的复制操作，效率将会降低，更关键的在于如果不想浪费一半的内存空间，就需要有额外空间进行分配担保，以应对被使用的内存中所有对象都是100%存活的极端情况，所以在老年代一般不能直接使用这种算法。![4](images\4.jpg)

​	根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程与“标记-清除”一样，但后续步骤不是进行清理，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。

### 3.4 分代收集算法

​	当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法根据对象存活周期的不同，将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法

在新生代，每次垃圾收集都有大量的对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

而老年代因为对象存活率高，没有额外空间进行分配担保，就必须使用“标记-清理”或者“标记-整理"算法进行回收。

## 4 hotspot算法实现

### 4.1 枚举根节点

​	从可达性分析中从GC Roots结点找引用链这个操作为例,可作为GC Roots的结点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中,现在很多应用仅仅方法区就有数百兆,如果要逐个检查这里面的引用,那么必然会消耗很多时间。

​	另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里“一致性”的意思是在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这是导致GC进行时必须停顿所有Java执行线程（Sun将这件事称之为“stop the world”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是要停顿的。

### 4.2 安全点

​	在OopMap的协助下，HotSpot可以快速且准确的完成GC Roots枚举，但HotSpot并不是为每条指令都生成OopMap，只是在特定的位置记录这些信息，这些位置称为"安全点"，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点是才能展厅。例如，方法调用、循环跳转、异常跳转等，这些功能的指令才能产生safepoint。

​	对于safepoint，另一个需要考虑的问题是如何在GC发生时让所有线程都跑到最近的安全点上在停下来。两种方案供选择：抢先式中断（Preemptive Suspension）和主动式终端（Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动配合，在GC发生时就首先把线程全部中断，如果有中断的地方不在安全点上，就回复线程，让它跑到安全点上。几乎没有虚拟机实现采用抢先式中断来展厅线程从而响应GC。而主动式的思想是GC需要中断线程时，不直接对线程操作，仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己主动挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

### 4.3 安全区域

​	当线程处于Sleep或者Blocked状态是，线程无法响应JVM的中断请求，走到安全点也无法中断挂起，JVM显然不会等待线程后重新被分配CPU的时间，这种情况就需要安全区域（Safe Region）解决。

​	安全区域指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的，我们也可以把Safe Region看做被扩展了的SafePoint。

​	在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者整个GC过程），如果完成了，那线程就继续执行，否则就必须等到直到收到可以安全离开safe region的信号为止。

## 5 垃圾收集器

### 5.1 Serial收集器

​       最悠久，最基本的收集器；**单线程**收集器，只使用一个CPU或一条收集线程去完成垃圾收集工作，且在收集时，必须暂停其他所有的工作线程，直到收集结束。**新生代采取复制算法**。老年代采取标记整理算法。在进行垃圾收集时必须暂停其他所有的工作线程，即“Stop The World”。依然是虚拟机运行在Client模式下的默认新生代收集器。简单而高效（与其他收集器单线程相比），对于单个CPU环境来说，Serial收集器由于没有线程交互的开销，专注于垃圾回收，因此能获得最高的单线程收集效率。

 ![5](images\5.jpg)

### 5.2 ParNew收集器

​       Serial收集器的多线程版。**多条线程**进行垃圾收集，采用**复制算法**。其余和Serial收集器一样。目前唯一能与CMS收集器配合工作。

![6](images\6.jpg)

### 5.3 Parallel Scavenge收集器

​        新生代收集器，**多线程并行**、使用**复制算法**。

  CMS的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而PS收集器的目的则是达到一个可控制的吞吐量。吞吐量即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间））。

![7](G:\J2EEGuideNew\JVM\02 垃圾收集器与内存分配策略\images\7.jpg)

### 5.4 Serial Old收集器

​        Serial Old同样是**单线程**收集器,使用“**标记-整理**”算法。可以与JDK1.5及之前的Parallel Scavenge搭配使用；也可以作为CMS收集器的后备预案，在并发收集发生Concureent Mode Failure时使用。

### 5.5 Parallel Old收集器

    Parallel Old收集器是**多线程**，使用“**标记-整理**”算法。

  JDK1.6前，Parallel Scavenge只能与老年代收集器Serial Old（PS MarkSweep）组合，由于Serial Old无法充分利用服务器多CPU的处理能力，会拖累整体性能。

  JDK1.6后，Parallel Scavenge可与Parallel Old组合，达到名副其实的“吞吐量优先”，在注重吞吐量以及CPU资源敏感的场合可以优先考虑这个组合。

### 5.6 CMS收集器

​       基于“**标记—清除**”算法，低停顿，**并发收集**。以获取最短回收停顿时间、低延迟为目标，适用于重视服务响应速度的应用。主要过程为以下四步：

- 初始标记；Stop the World，仅标记GCRoots能关联的对象，速度很快。

- 并发标记；进行GCRootsTracing的过程。

- 重新标记；修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比1长但远比2短。

- 并发清除；并发清除与并发标记耗时最长。收集器线程都可以与用户线程一起工作。并发清理以后重置线程

  ​

**CMS收集器的内存回收过程是与用户线程一起并发执行的**

**主要缺点：**

- CMS对CPU资源非常敏感。
- CMS无法处理浮动垃圾（Floating Garbage），可能出现Concurrent Mode Failure失败而导致另一次Full GC的产生。
- CMS是标记清除，会产生大量碎片空间，对大对象内存分配带来麻烦。

![8](images\8.jpg)

### 5.7 G1收集器

​        与其他基于分代的收集器不同，G1将整个Java堆划分为多个大小相等的独立区域Region，新生代和老年代不再是物理隔离的。

- 从整体来看：“标记-整理” 算法
- 从局部（两个Region之间）来看：“复制”算法

## 六、内存分配和回收策略

​	对象的内存分配从大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，少数情况下也有可能直接分配在老年代中，分配的规则并非百分之百固定的，细节取决于当前使用的是哪一种垃圾收集器的组合，还有虚拟机中与内存相关的参数设置。

### 1.对象优先分配在Eden

​	大多数情况下，对象在新生代的Eden区分配，当Eden区没有足够空间时，虚拟机将发起一次Minor GC。

### 2.大对象直接进入老年代

​	所谓大对象是指需要大量连续内存空间的对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发GC以获取足够的连续空间来“安置”它们。

### 3.长期存活的对象将进入老年代

​	虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能够被Survivor容纳，将被移动到Survivor空间中，并且对象年龄为1.对象在Survivor区每“熬过”一次Minor GC，年龄就增加一岁，当年龄增加到一定程度（默认为15岁），就将被晋升到老年代中。对象晋升老年代年龄的阈值，可以通过参数设置。

### 4.动态对象年龄判定

​	如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代，无需等到要求的年龄

### 5.空间分配担保

​	发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果成立，那么Minor GC确保是安全的，如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管是有风险的，如果小于或者设置不允许冒险，那这时也要进行一次Full GC。